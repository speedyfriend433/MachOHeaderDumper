//
//  HeaderGenerator.swift
//  MachOHeaderDumper
//
//  Created by 이지안 on 4/30/25.
//

import Foundation

enum HeaderGenError: Error {
    case typeDecodingError(encoding: String, underlying: Error)
}

class HeaderGenerator {
    private let metadata: ExtractedMetadata
    private let typeDecoder = TypeDecoder()
    private var output = ""
    private var indentLevel = 0
    private var knownClasses: Set<String>
    private var knownProtocols: Set<String>
    private var forwardDeclaredClasses: Set<String> = []
    private var forwardDeclaredProtocols: Set<String> = []
    
    // Configuration
    private var includeIvars: Bool = false // Option to include ivars
    
    init(metadata: ExtractedMetadata) {
        self.metadata = metadata
        self.knownClasses = Set(metadata.classes.keys)
        self.knownProtocols = Set(metadata.protocols.keys)
    }
    
    /// Generates the full header file content.
    /// - Parameter includeIvarsInHeader: If true, adds an ivar block to class interfaces.
    func generateHeader(includeIvarsInHeader: Bool = false) async throws -> String {
        self.includeIvars = includeIvarsInHeader
        output = ""
        indentLevel = 0
        forwardDeclaredClasses.removeAll()
        forwardDeclaredProtocols.removeAll()
        
        writeLine("// Generated by MachOHeaderDumper")
        writeLine("// Timestamp: \(Date())")
        writeLine("")
        
        // Forward Declarations (Phase 1: Collect - Now includes method/prop types)
        try collectForwardDeclarations() // Make it throwing
        
        // Forward Declarations (Phase 2: Write)
        writeForwardDeclarations()
        
        // Protocols
        if !metadata.protocols.isEmpty {
            writeLine("// MARK: - Protocols")
            let sortedProtocols = metadata.protocols.values.sorted { $0.name < $1.name }
            for proto in sortedProtocols {
                try writeProtocolDefinition(proto)
                writeLine("") // Add spacing
            }
        }
        
        // Interfaces
        if !metadata.classes.isEmpty {
            writeLine("// MARK: - Interfaces")
            let sortedClasses = metadata.classes.values.sorted { $0.name < $1.name }
            for cls in sortedClasses {
                try writeClassDefinition(cls)
                writeLine("") // Add spacing
            }
        }
        
        return output
    }
    
    // MARK: - Output Helpers
    
    private func indent() {
        indentLevel += 1
    }
    
    private func dedent() {
        indentLevel = max(0, indentLevel - 1)
    }
    
    private func writeLine(_ line: String = "") {
        let prefix = String(repeating: "    ", count: indentLevel) // 4 spaces indent
        output += prefix + line + "\n"
    }
    
    // MARK: - Forward Declaration Logic (Updated)
    
    private func collectForwardDeclarations() throws {
        // Check superclasses and adopted protocols
        for cls in metadata.classes.values {
            checkAndAddForwardDecl(name: cls.superclassName, isClass: true)
            cls.adoptedProtocols.forEach { checkAndAddForwardDecl(name: $0, isClass: false) }
            // Check types used in methods/properties
            try cls.properties.forEach { try collectTypes(from: $0.attributes) } // Need to parse type from attributes
            try cls.instanceMethods.forEach { try collectTypes(from: $0.typeEncoding) }
            try cls.classMethods.forEach { try collectTypes(from: $0.typeEncoding) }
            try cls.ivars.forEach { try collectTypes(from: $0.typeEncoding) }
        }
        // Check base protocols and their methods/properties
        for proto in metadata.protocols.values {
            proto.baseProtocols.forEach { checkAndAddForwardDecl(name: $0, isClass: false) }
            try proto.instanceProperties.forEach { try collectTypes(from: $0.attributes) }
            try proto.instanceMethods.forEach { try collectTypes(from: $0.typeEncoding) }
            try proto.classMethods.forEach { try collectTypes(from: $0.typeEncoding) }
            try proto.optionalInstanceMethods.forEach { try collectTypes(from: $0.typeEncoding) }
            try proto.optionalClassMethods.forEach { try collectTypes(from: $0.typeEncoding) }
        }
    }
    
    /// Checks a type name and adds it to forward declaration sets if needed.
    private func checkAndAddForwardDecl(name: String?, isClass: Bool) {
        guard let name = name, !name.isEmpty, name != "NSObject", name != "NSProxy" else { return } // Skip nil/empty/common roots
        if isClass {
            if !knownClasses.contains(name) && !name.hasPrefix("<") /* Avoid protocol names like <Proto> */ {
                forwardDeclaredClasses.insert(name)
            }
        } else {
            if !knownProtocols.contains(name) {
                forwardDeclaredProtocols.insert(name)
            }
        }
    }
    
    /// Decodes an encoding string and collects class/protocol names found within it.
    private func collectTypes(from encoding: String?) throws {
        guard let encoding = encoding, !encoding.isEmpty else { return }
        
        // Special handling for property attributes string: extract just the type part
        var typeEncodingToDecode = encoding
        if encoding.contains(",") && encoding.hasPrefix("T") { // Likely property attributes
            if let typePart = encoding.split(separator: ",").first(where: { $0.hasPrefix("T") }) {
                typeEncodingToDecode = String(typePart.dropFirst()) // Remove 'T'
            } else { return } // No 'T' found
        }
        
        // If it's a method encoding, parse args and return type
        if typeEncodingToDecode.contains(":") || typeEncodingToDecode.range(of: #"^[v@#][@:]"#, options: .regularExpression) != nil { // Basic check for method
            do {
                let signature = try typeDecoder.decodeMethodEncoding(typeEncodingToDecode)
                collectTypes(fromDecoded: signature.returnType)
                signature.arguments.forEach { collectTypes(fromDecoded: $0) }
            } catch {
                print("Warning: Failed to decode method encoding for forward decl collection: \(typeEncodingToDecode) - \(error)")
                // Attempt basic object scanning as fallback
                scanForObjectNames(in: typeEncodingToDecode)
            }
        } else { // Assume single type encoding
            do {
                let decodedType = try typeDecoder.decodeType(typeEncodingToDecode)
                collectTypes(fromDecoded: decodedType)
            } catch {
                print("Warning: Failed to decode type encoding for forward decl collection: \(typeEncodingToDecode) - \(error)")
                // Attempt basic object scanning as fallback
                scanForObjectNames(in: typeEncodingToDecode)
            }
        }
    }
    
    /// Recursively collects types from a DecodedType structure.
    private func collectTypes(fromDecoded decoded: DecodedType) {
        switch decoded {
        case .class(let name):
            checkAndAddForwardDecl(name: name, isClass: true) // Could be Class type
        case .object(let name):
            checkAndAddForwardDecl(name: name, isClass: true)
        case .pointer(let pointee):
            if let pointee = pointee { collectTypes(fromDecoded: pointee) }
        case .struct(_, let members):
            members?.forEach { collectTypes(fromDecoded: $0.1) }
        case .union(_, let members):
            members?.forEach { collectTypes(fromDecoded: $0.1) }
        case .array(_, let elementType):
            collectTypes(fromDecoded: elementType)
        case .block: // TODO: Parse block signature if implemented in decoder
            break
        default: // Other basic types don't need forward decl
            break
        }
    }
    
    /// Fallback: Scans encoding string for @"Name" patterns.
    private func scanForObjectNames(in encoding: String) {
        do {
            let regex = try NSRegularExpression(pattern: #"@"([^"]+)"#) // @"Name"
            let nsRange = NSRange(encoding.startIndex..<encoding.endIndex, in: encoding)
            regex.enumerateMatches(in: encoding, options: [], range: nsRange) { match, _, _ in
                guard let match = match, match.numberOfRanges == 2 else { return }
                if let range = Range(match.range(at: 1), in: encoding) {
                    let name = String(encoding[range])
                    checkAndAddForwardDecl(name: name, isClass: true)
                }
            }
        } catch {
            print("Warning: Regex error scanning for object names: \(error)")
        }
    }
    
    private func writeForwardDeclarations() {
        if !forwardDeclaredClasses.isEmpty {
            writeLine("@class \(forwardDeclaredClasses.sorted().joined(separator: ", "));")
        }
        if !forwardDeclaredProtocols.isEmpty {
            writeLine("@protocol \(forwardDeclaredProtocols.sorted().joined(separator: ", "));")
        }
        if !forwardDeclaredClasses.isEmpty || !forwardDeclaredProtocols.isEmpty {
            writeLine("") // Add spacing if declarations were written
        }
    }
    
    // MARK: - Definition Writing (Updated)
    
    
    private func writeProtocolDefinition(_ proto: ObjCProtocol) throws {
        var declaration = "@protocol \(proto.name)"
        if !proto.baseProtocols.isEmpty { declaration += " <\(proto.baseProtocols.sorted().joined(separator: ", "))>" }
        writeLine(declaration)
        
        try writeProperties(proto.instanceProperties)
        try writeClassProperties(proto.classProperties) // <-- ADDED Class Properties
        
        try writeMethods(proto.instanceMethods, isClassMethod: false, contextName: proto.name)
        try writeMethods(proto.classMethods, isClassMethod: true, contextName: proto.name)
        try writeMethods(proto.optionalInstanceMethods, isClassMethod: false, isOptional: true, contextName: proto.name)
        try writeMethods(proto.optionalClassMethods, isClassMethod: true, isOptional: true, contextName: proto.name)
        
        writeLine("@end")
    }
    
    private func writeClassDefinition(_ cls: ObjCClass) throws {
        if cls.superclassName == nil { writeLine("__attribute__((objc_root_class))") }
        
        var declaration = "@interface \(cls.name)"
        if let superName = cls.superclassName { declaration += " : \(superName)" }
        if !cls.adoptedProtocols.isEmpty { declaration += " <\(cls.adoptedProtocols.sorted().joined(separator: ", "))>" }
        writeLine(declaration)
        
        if includeIvars && !cls.ivars.isEmpty { try writeIVarBlock(cls.ivars) }
        
        try writeProperties(cls.properties) // Instance properties
        try writeClassProperties(cls.classProperties) // <-- ADDED Class Properties
        
        try writeMethods(cls.instanceMethods, isClassMethod: false, contextName: cls.name) // Pass class name
        try writeMethods(cls.classMethods, isClassMethod: true, contextName: cls.name) // Pass class name
        
        writeLine("@end")
    }
    
    // IMPLEMENTED: IVAR Block Writing
    private func writeIVarBlock(_ ivars: [ObjCIVar]) throws {
        writeLine("{") // Start ivar block
        indent()
        for ivar in ivars.sorted(by: { $0.offset < $1.offset }) { // Sort by offset for readability
            do {
                let decodedType = try typeDecoder.decodeType(ivar.typeEncoding)
                let typeString = decodedType.toObjCString(typeNamer: typeNameMapper)
                writeLine("\(typeString) \(ivar.name); // Offset: \(ivar.offset), Size: \(ivar.size)")
            } catch {
                writeLine("id /* Error decoding ivar type: \(ivar.typeEncoding) */ \(ivar.name);")
            }
        }
        dedent()
        writeLine("}") // End ivar block
        writeLine() // Add blank line after ivar block
    }
    
    // Updated to handle common logic for instance/class properties
    private func writeProperties(_ properties: [ObjCProperty], isClassProperty: Bool = false) throws {
        guard !properties.isEmpty else { return }
        
        let prefix = isClassProperty ? "+ " : "" // For potential future annotations
        
        // Sort properties alphabetically
        for prop in properties.sorted(by: { $0.name < $1.name }) {
            let attributes = parsePropertyAttributes(prop.attributes)
            let attrsString = attributes.displayString.isEmpty ? "" : "(\(attributes.displayString)) "
            let typeString: String
            if let typeEncoding = attributes.typeEncoding {
                do {
                    let decodedType = try typeDecoder.decodeType(typeEncoding)
                    // ADDED: Type mapping heuristic
                    typeString = mapCommonTypedefs(decodedType.toObjCString(typeNamer: typeNameMapper)) + " "
                } catch {
                    print("Warning: Failed to decode property type '\(typeEncoding)' for \(prop.name): \(error)")
                    typeString = "id "
                }
            } else {
                typeString = "id "
            }
            let finalTypeString = typeString.trimmingCharacters(in: .whitespaces)
            let requiresPointer = (finalTypeString != "id" && attributes.isObjectType) && !finalTypeString.hasSuffix("*")
            let pointer = requiresPointer ? "*" : ""
            
            // Add @property classifier for class properties
            let propertyKind = isClassProperty ? "class, " : ""
            let finalAttrsString = attributes.displayString.isEmpty ? propertyKind.dropLast(2) : "\(propertyKind)\(attributes.displayString)" // Add 'class'
            let finalAttrsParens = finalAttrsString.isEmpty ? "" : "(\(finalAttrsString)) "
            
            writeLine("@property \(finalAttrsParens)\(finalTypeString)\(pointer)\(prop.name);")
        }
        writeLine()
    }
    
    // Convenience wrapper for class properties
    private func writeClassProperties(_ properties: [ObjCProperty]) throws {
        try writeProperties(properties, isClassProperty: true)
    }
    
    // Updated to handle instancetype and pass context name
    private func writeMethods(_ methods: [ObjCMethod], isClassMethod: Bool, isOptional: Bool = false, contextName: String) throws {
        guard !methods.isEmpty else { return }
        
        if isOptional { writeLine("@optional") }
        
        let prefix = isClassMethod ? "+" : "-"
        for method in methods.sorted(by: { $0.name < $1.name }) {
            do {
                let signature = try typeDecoder.decodeMethodEncoding(method.typeEncoding)
                var returnTypeStr = mapCommonTypedefs(signature.returnType.toObjCString(typeNamer: typeNameMapper))
                
                // --- Instancetype Heuristic ---
                if !isClassMethod && signature.arguments.count >= 1 { // Need at least 'self'
                    let firstArgType = signature.arguments[0] // Implicit 'self' argument
                    // Check if return type and first arg are object pointers to the current class/protocol
                    if case .class = signature.returnType, case .class = firstArgType { // id method(id self, ...)
                        returnTypeStr = "instancetype"
                    } else if case .object(let retClassName) = signature.returnType,
                              case .object(let argClassName) = firstArgType,
                              retClassName == contextName, argClassName == contextName { // Class * method(Class * self, ...)
                        returnTypeStr = "instancetype"
                    } else if method.name.hasPrefix("init") && returnTypeStr == "id" { // Common init pattern
                        returnTypeStr = "instancetype"
                    }
                    // Could add more heuristics (e.g., methods named `sharedInstance` returning id)
                }
                // --- End Instancetype ---
                
                
                let components = method.name.split(separator: ":").map(String.init)
                var methodSignature = "\(prefix) (\(returnTypeStr))"
                let args = signature.arguments.dropFirst(2) // Skip self, _cmd
                
                if components.isEmpty {
                    methodSignature += "\(method.name)" // e.g., init, description
                } else {
                    for i in 0..<components.count {
                        methodSignature += "\(components[i])"
                        if i < args.count {
                            let argType = args[args.index(args.startIndex, offsetBy: i)]
                            let argTypeStr = mapCommonTypedefs(argType.toObjCString(typeNamer: typeNameMapper))
                            methodSignature += ":(\(argTypeStr))arg\(i+1)"
                        } else {
                            methodSignature += ":" // Type missing? Should align usually.
                        }
                        if i < components.count - 1 { methodSignature += " " }
                    }
                }
                writeLine("\(methodSignature);")
                
            } catch {
                // Write raw signature if decoding fails
                writeLine("\(prefix) (void) /* Error decoding ' \(method.name)' - \(method.typeEncoding) : \(error) */;")
            }
        }
    }
    
    // MARK: - Property Attribute Parsing
    
    private struct ParsedPropertyAttributes {
        var isNonatomic = false
        var isReadOnly = false
        var isCopy = false
        var isRetain = false
        var isWeak = false
        var isStrong = false // Implicit unless weak/copy/assign
        var isAssign = false // Explicit assign (or default for non-objects)
        var customGetter: String?
        var customSetter: String?
        var typeEncoding: String?
        var ivarName: String?
        var isObjectType: Bool = false // Track if 'T@' was found
        
        var displayString: String {
            var parts: [String] = []
            if isNonatomic { parts.append("nonatomic") } else { /* parts.append("atomic") */ } // Atomic is default
            
            if isReadOnly { parts.append("readonly") } else { /* parts.append("readwrite") */ } // Readwrite default
            
            // Memory management (prioritize common ones)
            if isCopy { parts.append("copy") }
            else if isRetain { parts.append("retain") } // Or strong
            else if isWeak { parts.append("weak") }
            else if isAssign { parts.append("assign") }
            else if isStrong { parts.append("strong") }
            else { /* Default based on type (assign/strong) */ }
            
            if let getter = customGetter { parts.append("getter=\(getter)") }
            if let setter = customSetter { parts.append("setter=\(setter)") }
            
            return parts.joined(separator: ", ")
        }
    }
    
    private func parsePropertyAttributes(_ attrsString: String) -> ParsedPropertyAttributes {
        var parsed = ParsedPropertyAttributes()
        let components = attrsString.split(separator: ",")
        
        for component in components {
            let comp = String(component)
            if comp == "N" { parsed.isNonatomic = true; continue }
            if comp == "R" { parsed.isReadOnly = true; continue }
            if comp == "C" { parsed.isCopy = true; continue }
            if comp == "&" { parsed.isRetain = true; parsed.isStrong = true; continue } // Retain often means strong now
            if comp == "W" { parsed.isWeak = true; continue }
            // Note: 'assign' is often implicit for non-objects and doesn't have a specific code usually.
            // We might set parsed.isAssign = true if it's NOT C, &, W and not an object.
            
            if comp.hasPrefix("T") {
                // Type encoding (e.g., T@"NSString", Ti, T^{_CGRect})
                parsed.typeEncoding = String(comp.dropFirst())
                if parsed.typeEncoding?.hasPrefix("@") == true || parsed.typeEncoding?.hasPrefix("#") == true {
                    parsed.isObjectType = true
                }
                continue
            }
            if comp.hasPrefix("G") { parsed.customGetter = String(comp.dropFirst()); continue } // G<name>
            if comp.hasPrefix("S") { parsed.customSetter = String(comp.dropFirst()); continue } // S<name>[:
            if comp.hasPrefix("V") { parsed.ivarName = String(comp.dropFirst()); continue } // V<name>
        }
        
        // Infer 'strong' if it's an object type and not weak/copy/assign/retain
        if parsed.isObjectType && !parsed.isWeak && !parsed.isCopy && !parsed.isRetain && !parsed.isAssign {
            parsed.isStrong = true
        }
        // Infer 'assign' if not an object and not weak/copy/retain/strong
        if !parsed.isObjectType && !parsed.isWeak && !parsed.isCopy && !parsed.isRetain && !parsed.isStrong {
            parsed.isAssign = true // Default for primitives
        }
        
        
        return parsed
    }
    
    /// Simple mapper for common struct names often encoded without the underscore prefix.
    private func typeNameMapper(_ encodedName: String) -> String? {
        // Example: Map _CGRect -> CGRect
        if encodedName.hasPrefix("_") {
            return String(encodedName.dropFirst())
        }
        // Add other known mappings if necessary
        return encodedName // Return original if no mapping
    }
}
    // ADDED: Simple typedef mapping
       private func mapCommonTypedefs(_ typeName: String) -> String {
           // Remove pointer qualifiers for mapping check
           let baseType = typeName.replacingOccurrences(of: "*", with: "").trimmingCharacters(in: .whitespaces)
           let pointerSuffix = String(repeating: " *", count: typeName.filter { $0 == "*" }.count)

           var mappedBase: String? = nil
           switch baseType {
           case "long long", "q": mappedBase = "NSInteger" // Common 64-bit mapping
           case "unsigned long long", "Q": mappedBase = "NSUInteger"
           // Add other common mappings if desired (CGFloat, etc.)
           // case "double", "d": mappedBase = "CGFloat" // Be careful with this one
           default: break
           }

           return (mappedBase ?? baseType) + pointerSuffix
       }
